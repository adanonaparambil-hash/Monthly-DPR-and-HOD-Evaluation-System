import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Theme } from '../services/theme';
import { Api } from '../services/api';

interface LoggedHour {
  id: string;
  taskId?: string;
  title: string;
  description: string;
  category: string;
  type?: string;
  process?: string;
  assignedTo?: string;
  assignedBy?: string;
  department?: string;
  project?: string;
  workPlace?: string;
  trade?: string;
  stage?: string;
  section?: string;
  startDate?: string;
  targetDate?: string;
  timeTaken?: string;
  progress?: number;
  status?: string;
  instruction?: string;
  count?: number;
  unit?: string;
  remarks?: string;
  folderPath?: string;
  documentLink?: string;
  priority?: string;
  duration: string;
  date: string;
  loggedBy: string;
  dailyComment?: string;
}

interface Project {
  projectId: number;
  projectName: string;
  departmentId?: number;
  isActive?: string;
}

interface Department {
  departmentId: number;
  deptCode: string;
  deptName: string;
  status: string;
}

interface TaskCategory {
  categoryId: number;
  categoryName: string;
  departmentId: number;
  departmentName?: string;
}

interface ColumnDefinition {
  key: string;
  label: string;
  visible: boolean;
  width?: string;
  type: 'text' | 'number' | 'date' | 'select' | 'percentage';
  required?: boolean;
}

@Component({
  selector: 'app-my-logged-hours',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './my-logged-hours.html',
  styleUrls: ['./my-logged-hours.css']
})
export class MyLoggedHoursComponent implements OnInit {
  isDarkMode = false;
  
  // Filter properties - Updated with API integration
  fromDate = '';
  toDate = '';
  selectedProject: string | number = 'all';
  selectedDepartment: string | number = 'all';
  selectedCategory: string | number = 'all';

  // API data
  projects: Project[] = [];
  departments: Department[] = [];
  taskCategories: TaskCategory[] = [];
  
  // Loading state
  isLoadingData = false;

  // Column management
  showColumnModal = false;
  availableColumns: ColumnDefinition[] = [
    { key: 'taskId', label: 'Task ID', visible: false, width: '120px', type: 'text' },
    { key: 'title', label: 'Task Title', visible: true, width: '250px', type: 'text', required: true },
    { key: 'description', label: 'Description', visible: true, width: '300px', type: 'text', required: true },
    { key: 'category', label: 'Task Category', visible: true, width: '180px', type: 'select', required: true },
    { key: 'type', label: 'Type', visible: false, width: '120px', type: 'select' },
    { key: 'process', label: 'Process', visible: false, width: '150px', type: 'text' },
    { key: 'assignedTo', label: 'Assigned To', visible: false, width: '150px', type: 'text' },
    { key: 'assignedBy', label: 'Assigned By', visible: false, width: '150px', type: 'text' },
    { key: 'department', label: 'Department', visible: false, width: '130px', type: 'select' },
    { key: 'project', label: 'Project', visible: false, width: '180px', type: 'text' },
    { key: 'workPlace', label: 'Work Place', visible: false, width: '130px', type: 'select' },
    { key: 'trade', label: 'Trade', visible: false, width: '120px', type: 'select' },
    { key: 'stage', label: 'Stage', visible: false, width: '120px', type: 'select' },
    { key: 'section', label: 'Section', visible: false, width: '120px', type: 'select' },
    { key: 'startDate', label: 'Start Date', visible: false, width: '130px', type: 'date' },
    { key: 'targetDate', label: 'Target Date', visible: false, width: '130px', type: 'date' },
    { key: 'timeTaken', label: 'Time Taken', visible: false, width: '120px', type: 'text' },
    { key: 'progress', label: 'Progress (%)', visible: false, width: '140px', type: 'percentage' },
    { key: 'status', label: 'Status', visible: false, width: '120px', type: 'select' },
    { key: 'instruction', label: 'Instruction', visible: false, width: '200px', type: 'text' },
    { key: 'count', label: 'Count', visible: false, width: '100px', type: 'number' },
    { key: 'unit', label: 'Unit', visible: false, width: '100px', type: 'select' },
    { key: 'remarks', label: 'Remarks', visible: false, width: '200px', type: 'text' },
    { key: 'folderPath', label: 'Folder Path', visible: false, width: '200px', type: 'text' },
    { key: 'documentLink', label: 'Document Link', visible: false, width: '200px', type: 'text' },
    { key: 'loggedBy', label: 'Logged By', visible: true, width: '150px', type: 'text', required: true },
    { key: 'duration', label: 'Duration', visible: true, width: '120px', type: 'text', required: true }
  ];

  // Sample data
  loggedHours: LoggedHour[] = [
    // Today's records
    {
      id: '1',
      taskId: 'TSK-204',
      title: 'Implement OAuth2 Authentication Flow',
      description: 'Refactored the token exchange logic and integrated PKCE for better security.',
      category: 'Security Enhancement',
      type: 'Feature',
      process: 'Development',
      assignedTo: 'John Smith',
      assignedBy: 'Marcus Thorne',
      department: 'Engineering',
      project: 'Identity Management v3',
      workPlace: 'Office',
      trade: 'Development',
      stage: 'Development',
      section: 'Backend',
      startDate: '2023-10-20',
      targetDate: '2023-10-30',
      timeTaken: '4h 20m',
      progress: 75,
      status: 'In Progress',
      instruction: 'Ensure PKCE compliance and test with multiple OAuth providers',
      count: 3,
      unit: 'Features',
      remarks: 'Good progress, needs testing',
      folderPath: '/projects/auth/oauth2',
      documentLink: 'https://docs.company.com/oauth2-spec',
      duration: '04:20',
      date: '2023-10-26',
      loggedBy: 'John Smith'
    },
    {
      id: '2',
      taskId: 'TSK-189',
      title: 'Database Schema Migration',
      description: 'Finalized the user metadata expansion script and tested on staging.',
      category: 'Back-end',
      type: 'Maintenance',
      process: 'Database',
      assignedTo: 'Sarah Johnson',
      assignedBy: 'Alex Chen',
      department: 'Engineering',
      project: 'Core Platform',
      workPlace: 'Remote',
      trade: 'Database',
      stage: 'Testing',
      section: 'Database',
      startDate: '2023-10-22',
      targetDate: '2023-10-28',
      timeTaken: '1h 52m',
      progress: 90,
      status: 'Review Required',
      instruction: 'Test migration on staging before production deployment',
      count: 5,
      unit: 'Tables',
      remarks: 'Migration script ready for review',
      folderPath: '/database/migrations',
      documentLink: 'https://docs.company.com/db-migration',
      duration: '01:52',
      date: '2023-10-26',
      loggedBy: 'Sarah Johnson'
    },
    {
      id: '3',
      taskId: 'TSK-205',
      title: 'Team Standup',
      description: 'Daily sync with engineering team.',
      category: 'Meeting',
      type: 'Meeting',
      process: 'Communication',
      assignedTo: 'Mike Davis',
      assignedBy: 'Team Lead',
      department: 'Engineering',
      project: 'General',
      workPlace: 'Office',
      trade: 'Management',
      stage: 'Planning',
      section: 'Management',
      startDate: '2023-10-26',
      targetDate: '2023-10-26',
      timeTaken: '30m',
      progress: 100,
      status: 'Completed',
      instruction: 'Regular daily standup meeting',
      count: 1,
      unit: 'Meeting',
      remarks: 'Good team sync',
      folderPath: '/meetings/standup',
      documentLink: 'https://calendar.company.com/standup',
      duration: '00:30',
      date: '2023-10-26',
      loggedBy: 'Mike Davis'
    },
    // Yesterday's records
    {
      id: '4',
      taskId: 'TSK-210',
      title: 'UI Polish - Dashboard Widgets',
      description: 'Adjusted spacing and added empty state illustrations for the analytics tab.',
      category: 'Feature Development',
      type: 'Enhancement',
      process: 'UI/UX',
      assignedTo: 'Emily Chen',
      assignedBy: 'Design Lead',
      department: 'Design',
      project: 'Dashboard v2',
      workPlace: 'Office',
      trade: 'Design',
      stage: 'Development',
      section: 'Frontend',
      startDate: '2023-10-24',
      targetDate: '2023-10-27',
      timeTaken: '8h 15m',
      progress: 85,
      status: 'In Progress',
      instruction: 'Focus on responsive design and accessibility',
      count: 4,
      unit: 'Widgets',
      remarks: 'Great visual improvements',
      folderPath: '/ui/dashboard/widgets',
      documentLink: 'https://figma.com/dashboard-widgets',
      duration: '08:15',
      date: '2023-10-25',
      loggedBy: 'Emily Chen'
    },
    {
      id: '5',
      taskId: 'TSK-211',
      title: 'Code Review: PR #405',
      description: 'Reviewing the new notification system implementation.',
      category: 'Code Review',
      type: 'Review',
      process: 'Quality Assurance',
      assignedTo: 'Alex Rodriguez',
      assignedBy: 'Senior Developer',
      department: 'Engineering',
      project: 'Notification System',
      workPlace: 'Remote',
      trade: 'Development',
      stage: 'Review',
      section: 'Backend',
      startDate: '2023-10-25',
      targetDate: '2023-10-25',
      timeTaken: '1h 15m',
      progress: 100,
      status: 'Completed',
      instruction: 'Review code quality, performance, and security aspects',
      count: 1,
      unit: 'PR',
      remarks: 'Code looks good, minor suggestions provided',
      folderPath: '/reviews/pr-405',
      documentLink: 'https://github.com/company/repo/pull/405',
      duration: '01:15',
      date: '2023-10-25',
      loggedBy: 'Alex Rodriguez'
    },
    // Tuesday's records
    {
      id: '6',
      taskId: 'TSK-202',
      title: 'Critical Bug: Data Export Failure',
      description: 'Hotfix deployed to production. Memory leak during large CSV generation was resolved.',
      category: 'Bug Fix',
      type: 'Bug Fix',
      process: 'Maintenance',
      assignedTo: 'David Wilson',
      assignedBy: 'Product Manager',
      department: 'Engineering',
      project: 'Data Platform',
      workPlace: 'Office',
      trade: 'Development',
      stage: 'Production',
      section: 'Backend',
      startDate: '2023-10-24',
      targetDate: '2023-10-24',
      timeTaken: '7h 30m',
      progress: 100,
      status: 'Completed',
      instruction: 'Critical production issue - immediate fix required',
      count: 1,
      unit: 'Bug',
      remarks: 'Successfully resolved memory leak issue',
      folderPath: '/hotfixes/data-export',
      documentLink: 'https://jira.company.com/TSK-202',
      priority: 'High Priority',
      duration: '07:30',
      date: '2023-10-24',
      loggedBy: 'David Wilson'
    }
  ];

  constructor(
    private themeService: Theme,
    private api: Api
  ) {}

  ngOnInit() {
    // Subscribe to theme changes
    this.themeService.isDarkMode$.subscribe(isDark => {
      this.isDarkMode = isDark;
    });
    
    // Set default date range (last 7 days)
    const today = new Date();
    const lastWeek = new Date(today);
    lastWeek.setDate(today.getDate() - 7);
    
    this.toDate = this.formatDateForInput(today);
    this.fromDate = this.formatDateForInput(lastWeek);
    
    // Load dropdown data from API
    this.loadProjects();
    this.loadDepartments();
    
    // Load logged hours data
    this.loadLoggedHours();
  }

  formatDateForInput(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  loadProjects() {
    console.log('Loading projects for My Logged Hours');
    
    this.api.getProjects().subscribe({
      next: (response) => {
        console.log('getProjects API Response:', response);
        
        if (response.success && response.data) {
          this.projects = response.data;
          console.log('Loaded projects:', this.projects.length);
        } else {
          console.warn('API response success is false or no data:', response);
        }
      },
      error: (error) => {
        console.error('Error loading projects:', error);
      }
    });
  }

  loadDepartments() {
    console.log('Loading departments for My Logged Hours');
    
    this.api.getDepartmentList().subscribe({
      next: (response) => {
        console.log('getDepartmentList API Response:', response);
        
        if (response.success && response.data) {
          // Filter only active departments (status === 'Y')
          this.departments = response.data.filter((dept: Department) => dept.status === 'Y');
          console.log('Loaded departments:', this.departments.length);
        } else {
          console.warn('API response success is false or no data:', response);
        }
      },
      error: (error) => {
        console.error('Error loading departments:', error);
      }
    });
  }

  onDepartmentChange() {
    console.log('Department changed to:', this.selectedDepartment);
    
    // Reset task category selection
    this.selectedCategory = 'all';
    this.taskCategories = [];
    
    // If "All Departments" is selected, don't load categories
    if (this.selectedDepartment === 'all') {
      // Reload logged hours with updated filter
      this.loadLoggedHours();
      return;
    }
    
    // Load task categories for the selected department
    this.loadDepartmentTaskCategories(Number(this.selectedDepartment));
    
    // Reload logged hours with updated filter
    this.loadLoggedHours();
  }

  loadDepartmentTaskCategories(departmentId: number) {
    console.log('Loading task categories for department:', departmentId);
    
    this.api.getDepartmentTaskCategories(departmentId).subscribe({
      next: (response) => {
        console.log('getDepartmentTaskCategories API Response:', response);
        
        if (response.success && response.data) {
          // Combine all categories from favouriteList, departmentList, and allDepartmentList
          const allCategories = [
            ...(response.data.favouriteList || []),
            ...(response.data.departmentList || []),
            ...(response.data.allDepartmentList || [])
          ];
          
          // Remove duplicates based on categoryId
          const uniqueCategories = allCategories.filter((category, index, self) =>
            index === self.findIndex((c) => c.categoryId === category.categoryId)
          );
          
          this.taskCategories = uniqueCategories;
          console.log('Loaded task categories:', this.taskCategories.length);
        } else {
          console.warn('API response success is false or no data:', response);
        }
      },
      error: (error) => {
        console.error('Error loading task categories:', error);
      }
    });
  }

  onProjectChange() {
    console.log('Project changed to:', this.selectedProject);
    // Reload logged hours with updated filter
    this.loadLoggedHours();
  }

  onCategoryChange() {
    console.log('Category changed to:', this.selectedCategory);
    // Reload logged hours with updated filter
    this.loadLoggedHours();
  }

  onDateChange() {
    console.log('Date range changed:', this.fromDate, 'to', this.toDate);
    // Reload logged hours with updated filter
    this.loadLoggedHours();
  }

  loadLoggedHours() {
    console.log('Loading logged hours from API');
    this.isLoadingData = true;
    
    // Get current user
    const currentUser = JSON.parse(localStorage.getItem('current_user') || '{}');
    const userId = currentUser.empId || currentUser.employeeId || '';
    
    if (!userId) {
      console.error('No user ID found');
      this.isLoadingData = false;
      return;
    }
    
    const request = {
      userId: userId,
      fromDate: this.fromDate || undefined,
      toDate: this.toDate || undefined,
      projectId: this.selectedProject !== 'all' ? Number(this.selectedProject) : undefined,
      categoryId: this.selectedCategory !== 'all' ? Number(this.selectedCategory) : undefined
    };
    
    console.log('getUserDailyLogHistory request:', request);
    
    this.api.getUserDailyLogHistory(request).subscribe({
      next: (response) => {
        console.log('getUserDailyLogHistory API Response:', response);
        
        if (response && response.success && response.data) {
          // Map API response to LoggedHour interface
          this.loggedHours = response.data.map((log: any, index: number) => ({
            id: `${log.taskId}-${index}`,
            taskId: `TSK-${log.taskId}`,
            title: log.taskTitle || 'Untitled Task',
            description: log.description || log.dailyComment || 'No description',
            category: log.categoryName || 'Uncategorized',
            duration: log.duration || '00:00',
            date: log.logDate ? log.logDate.split('T')[0] : '',
            project: log.projectName || 'No Project',
            loggedBy: log.loggedBy || '',
            dailyComment: log.dailyComment || ''
          }));
          
          console.log('Loaded logged hours:', this.loggedHours.length, 'records');
        } else if (response && Array.isArray(response.data)) {
          // Handle direct array response
          this.loggedHours = response.data.map((log: any, index: number) => ({
            id: `${log.taskId}-${index}`,
            taskId: `TSK-${log.taskId}`,
            title: log.taskTitle || 'Untitled Task',
            description: log.description || log.dailyComment || 'No description',
            category: log.categoryName || 'Uncategorized',
            duration: log.duration || '00:00',
            date: log.logDate ? log.logDate.split('T')[0] : '',
            project: log.projectName || 'No Project',
            loggedBy: log.loggedBy || '',
            dailyComment: log.dailyComment || ''
          }));
          
          console.log('Loaded logged hours (direct array):', this.loggedHours.length, 'records');
        } else {
          console.warn('No logged hours data found');
          this.loggedHours = [];
        }
        
        this.isLoadingData = false;
      },
      error: (error) => {
        console.error('Error loading logged hours:', error);
        this.loggedHours = [];
        this.isLoadingData = false;
      }
    });
  }

  // Group logged hours by date
  getGroupedLoggedHours(): { date: string; displayDate: string; displayDay: string; records: LoggedHour[] }[] {
    // Group records by date
    const grouped = this.loggedHours.reduce((acc, record) => {
      if (!acc[record.date]) {
        acc[record.date] = [];
      }
      acc[record.date].push(record);
      return acc;
    }, {} as { [key: string]: LoggedHour[] });
    
    // Convert to array and sort by date (newest first)
    const groupedArray = Object.keys(grouped).map(date => ({
      date: date,
      displayDate: this.formatDisplayDate(date),
      displayDay: this.formatDisplayDay(date),
      records: grouped[date]
    })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    
    return groupedArray;
  }

  formatDisplayDate(dateString: string): string {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const options: Intl.DateTimeFormatOptions = { month: 'short', day: 'numeric', year: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  }

  formatDisplayDay(dateString: string): string {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    
    // Reset time parts for comparison
    today.setHours(0, 0, 0, 0);
    yesterday.setHours(0, 0, 0, 0);
    date.setHours(0, 0, 0, 0);
    
    if (date.getTime() === today.getTime()) {
      return 'Today';
    } else if (date.getTime() === yesterday.getTime()) {
      return 'Yesterday';
    } else {
      const options: Intl.DateTimeFormatOptions = { weekday: 'long' };
      return date.toLocaleDateString('en-US', options);
    }
  }

  getTodayRecords(): LoggedHour[] {
    const today = this.formatDateForInput(new Date());
    return this.loggedHours.filter(record => record.date === today);
  }

  getYesterdayRecords(): LoggedHour[] {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = this.formatDateForInput(yesterday);
    return this.loggedHours.filter(record => record.date === yesterdayStr);
  }

  getTuesdayRecords(): LoggedHour[] {
    // Get records from 2 days ago
    const twoDaysAgo = new Date();
    twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
    const twoDaysAgoStr = this.formatDateForInput(twoDaysAgo);
    return this.loggedHours.filter(record => record.date === twoDaysAgoStr);
  }

  getCategoryClass(category: string): string {
    const categoryMap: { [key: string]: string } = {
      'Security Enhancement': 'security',
      'Back-end': 'backend',
      'Meeting': 'meeting',
      'Feature Development': 'feature',
      'Code Review': 'review',
      'Bug Fix': 'bug'
    };
    return categoryMap[category] || 'default';
  }

  getPriorityClass(priority: string): string {
    const priorityMap: { [key: string]: string } = {
      'High Priority': 'high',
      'Medium Priority': 'medium',
      'Low Priority': 'low'
    };
    return priorityMap[priority] || 'default';
  }

  exportReport() {
    // Implement export functionality
    console.log('Exporting report from', this.fromDate, 'to', this.toDate);
  }

  logNewHours() {
    // Implement add new hours functionality
    console.log('Opening add new hours modal...');
  }

  // Column management methods
  openColumnModal() {
    this.showColumnModal = true;
    document.body.style.overflow = 'hidden';
  }

  closeColumnModal() {
    this.showColumnModal = false;
    document.body.style.overflow = 'auto';
  }

  toggleColumn(columnKey: string) {
    const column = this.availableColumns.find(col => col.key === columnKey);
    if (column && !column.required) {
      column.visible = !column.visible;
    }
  }

  getVisibleColumns(): ColumnDefinition[] {
    return this.availableColumns.filter(col => col.visible);
  }

  resetColumns() {
    // Reset to default visible columns
    this.availableColumns.forEach(col => {
      col.visible = col.required || ['title', 'description', 'category', 'loggedBy', 'duration'].includes(col.key);
    });
  }

  applyColumnChanges() {
    this.closeColumnModal();
    // Column changes are automatically applied since we're using the same array
  }

  formatColumnValue(value: any, column: ColumnDefinition): string {
    if (!value && value !== 0) return '-';
    
    switch (column.type) {
      case 'percentage':
        return `${value}%`;
      case 'date':
        if (typeof value === 'string') {
          const date = new Date(value);
          return isNaN(date.getTime()) ? value : date.toLocaleDateString();
        }
        return value.toString();
      case 'number':
        return typeof value === 'number' ? value.toString() : value;
      case 'select':
        return value.toString();
      default:
        return value.toString();
    }
  }

  getGridTemplateColumns(): string {
    const visibleColumns = this.getVisibleColumns();
    
    // Calculate dynamic widths based on column content and type
    return visibleColumns.map(col => {
      // Set specific widths for different column types
      switch (col.key) {
        case 'title':
          return '300px'; // Wider for title + description
        case 'description':
          return '350px'; // Wide for description text
        case 'category':
          return '180px';
        case 'loggedBy':
          return '150px';
        case 'duration':
          return '120px';
        case 'progress':
          return '140px';
        case 'taskId':
          return '120px';
        case 'startDate':
        case 'targetDate':
          return '130px';
        case 'status':
        case 'type':
        case 'trade':
        case 'stage':
        case 'section':
          return '120px';
        case 'assignedTo':
        case 'assignedBy':
        case 'department':
          return '150px';
        case 'project':
        case 'workPlace':
          return '180px';
        case 'process':
        case 'instruction':
        case 'remarks':
          return '200px';
        case 'folderPath':
        case 'documentLink':
          return '250px';
        case 'count':
        case 'unit':
          return '100px';
        case 'timeTaken':
          return '120px';
        default:
          return col.width || '150px';
      }
    }).join(' ');
  }

  getRequiredColumnsCount(): number {
    return this.availableColumns.filter(col => col.required).length;
  }

  // Add tooltip functionality for truncated content
  getTooltipText(record: LoggedHour, columnKey: string): string {
    const value = this.getColumnValue(record, columnKey);
    return value ? value.toString() : '';
  }

  // Enhanced column value getter with better type handling
  getColumnValue(record: LoggedHour, columnKey: string): any {
    const value = (record as any)[columnKey];
    
    // Handle special cases
    if (columnKey === 'progress' && typeof value === 'number') {
      return Math.min(100, Math.max(0, value)); // Ensure progress is between 0-100
    }
    
    if (columnKey === 'count' && value === undefined) {
      return 0;
    }
    
    return value || '';
  }

  // Column search functionality
  searchColumns(searchTerm: string) {
    if (!searchTerm.trim()) {
      // Show all columns if search is empty
      return;
    }
    
    const term = searchTerm.toLowerCase();
    // This would filter the visible columns in the modal
    // Implementation depends on how you want to handle the search
    console.log('Searching columns for:', term);
  }

  // Method to get column statistics for the modal
  getColumnStats() {
    const visible = this.getVisibleColumns().length;
    const total = this.availableColumns.length;
    const required = this.getRequiredColumnsCount();
    
    return {
      visible,
      hidden: total - visible,
      required,
      total
    };
  }

  // Helper method to check if description column is visible
  isDescriptionColumnVisible(): boolean {
    return this.getVisibleColumns().some(col => col.key === 'description');
  }
}